<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/nova/doc/source/admin/configuration/schedulers.rst">
    <section ids="compute-schedulers" names="compute\ schedulers">
        <title>Compute schedulers</title>
        <paragraph>Compute uses the <literal>nova-scheduler</literal> service to determine how to dispatch
            compute requests. For example, the <literal>nova-scheduler</literal> service determines on
            which host a VM should launch.  In the context of filters, the term <literal>host</literal>
            means a physical node that has a <literal>nova-compute</literal> service running on it.  You
            can configure the scheduler through a variety of options.</paragraph>
        <paragraph>Compute is configured with the following default scheduler options in the
            <literal>/etc/nova/nova.conf</literal> file:</paragraph>
        <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_driver_task_period = 60
scheduler_driver = nova.scheduler.filter_scheduler.FilterScheduler
scheduler_available_filters = nova.scheduler.filters.all_filters
scheduler_default_filters = RetryFilter, AvailabilityZoneFilter, RamFilter, DiskFilter, ComputeFilter, ComputeCapabilitiesFilter, ImagePropertiesFilter, ServerGroupAntiAffinityFilter, ServerGroupAffinityFilter</literal_block>
        <paragraph>By default, the <literal>scheduler_driver</literal> is configured as a filter scheduler, as
            described in the next section. In the default configuration, this scheduler
            considers hosts that meet all the following criteria:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>Have not been attempted for scheduling purposes (<literal>RetryFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Are in the requested availability zone (<literal>AvailabilityZoneFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Have sufficient RAM available (<literal>RamFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Have sufficient disk space available for root and ephemeral storage
                    (<literal>DiskFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Can service the request (<literal>ComputeFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Satisfy the extra specs associated with the instance type
                    (<literal>ComputeCapabilitiesFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Satisfy any architecture, hypervisor type, or virtual machine mode properties
                    specified on the instance's image properties (<literal>ImagePropertiesFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Are on a different host than other instances of a group (if requested)
                    (<literal>ServerGroupAntiAffinityFilter</literal>).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Are in a set of group hosts (if requested) (<literal>ServerGroupAffinityFilter</literal>).</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>The scheduler caches its list of available hosts; use the
            <literal>scheduler_driver_task_period</literal> option to specify how often the list is
            updated.</paragraph>
        <note>
            <paragraph>Do not configure <literal>service_down_time</literal> to be much smaller than
                <literal>scheduler_driver_task_period</literal>; otherwise, hosts appear to be dead while
                the host list is being cached.</paragraph>
        </note>
        <paragraph>For information about the volume scheduler, see the <reference name="Block Storage section" refuri="https://docs.openstack.org/admin-guide/blockstorage-manage-volumes.html">Block Storage section</reference><target ids="block-storage-section" names="block\ storage\ section" refuri="https://docs.openstack.org/admin-guide/blockstorage-manage-volumes.html"></target> of
            OpenStack Administrator Guide.</paragraph>
        <paragraph>The scheduler chooses a new host when an instance is migrated.</paragraph>
        <paragraph>When evacuating instances from a host, the scheduler service honors the target
            host defined by the administrator on the <literal_strong classes="command">nova evacuate</literal_strong> command.  If
            a target is not defined by the administrator, the scheduler determines the
            target host. For information about instance evacuation, see <reference name="Evacuate instances" refuri="https://docs.openstack.org/admin-guide/compute-node-down.html#evacuate-instances">Evacuate instances</reference><target ids="evacuate-instances" names="evacuate\ instances" refuri="https://docs.openstack.org/admin-guide/compute-node-down.html#evacuate-instances"></target> section of the OpenStack
            Administrator Guide.</paragraph>
        <target refid="compute-scheduler-filters"></target>
        <section ids="filter-scheduler compute-scheduler-filters" names="filter\ scheduler compute-scheduler-filters">
            <title>Filter scheduler</title>
            <paragraph>The filter scheduler (<literal>nova.scheduler.filter_scheduler.FilterScheduler</literal>) is
                the default scheduler for scheduling virtual machine instances.  It supports
                filtering and weighting to make informed decisions on where a new instance
                should be created.</paragraph>
            <paragraph>When the filter scheduler receives a request for a resource, it first applies
                filters to determine which hosts are eligible for consideration when
                dispatching a resource. Filters are binary: either a host is accepted by the
                filter, or it is rejected. Hosts that are accepted by the filter are then
                processed by a different algorithm to decide which hosts to use for that
                request, described in the <reference internal="True" refid="weights"><inline classes="std std-ref">Weights</inline></reference> section.</paragraph>
            <paragraph><strong>Filtering</strong></paragraph>
            <figure>
                <image candidates="{'*': u'figures/filteringWorkflow1.png'}" uri="figures/filteringWorkflow1.png"></image>
            </figure>
            <paragraph>The <literal>scheduler_available_filters</literal> configuration option in <literal>nova.conf</literal>
                provides the Compute service with the list of the filters that are used by the
                scheduler. The default setting specifies all of the filter that are included
                with the Compute service:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_available_filters = nova.scheduler.filters.all_filters</literal_block>
            <paragraph>This configuration option can be specified multiple times.  For example, if you
                implemented your own custom filter in Python called <literal>myfilter.MyFilter</literal> and
                you wanted to use both the built-in filters and your custom filter, your
                <literal>nova.conf</literal> file would contain:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_available_filters = nova.scheduler.filters.all_filters
scheduler_available_filters = myfilter.MyFilter</literal_block>
            <paragraph>The <literal>scheduler_default_filters</literal> configuration option in <literal>nova.conf</literal> defines
                the list of filters that are applied by the <literal>nova-scheduler</literal> service. The
                default filters are:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_default_filters = RetryFilter, AvailabilityZoneFilter, RamFilter, ComputeFilter, ComputeCapabilitiesFilter, ImagePropertiesFilter, ServerGroupAntiAffinityFilter, ServerGroupAffinityFilter</literal_block>
        </section>
        <section ids="compute-filters" names="compute\ filters">
            <title>Compute filters</title>
            <paragraph>The following sections describe the available compute filters.</paragraph>
            <section ids="aggregatecorefilter" names="aggregatecorefilter">
                <title>AggregateCoreFilter</title>
                <paragraph>Filters host by CPU core numbers with a per-aggregate <literal>cpu_allocation_ratio</literal>
                    value. If the per-aggregate value is not found, the value falls back to the
                    global setting.  If the host is in more than one aggregate and more than one
                    value is found, the minimum value will be used.  For information about how to
                    use this filter, see <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>. See also <reference internal="True" refid="corefilter"><inline classes="std std-ref">CoreFilter</inline></reference>.</paragraph>
            </section>
            <section ids="aggregatediskfilter" names="aggregatediskfilter">
                <title>AggregateDiskFilter</title>
                <paragraph>Filters host by disk allocation with a per-aggregate <literal>disk_allocation_ratio</literal>
                    value. If the per-aggregate value is not found, the value falls back to the
                    global setting.  If the host is in more than one aggregate and more than one
                    value is found, the minimum value will be used.  For information about how to
                    use this filter, see <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>. See also <reference internal="True" refid="diskfilter"><inline classes="std std-ref">DiskFilter</inline></reference>.</paragraph>
            </section>
            <section ids="aggregateimagepropertiesisolation" names="aggregateimagepropertiesisolation">
                <title>AggregateImagePropertiesIsolation</title>
                <paragraph>Matches properties defined in an image's metadata against those of aggregates
                    to determine host matches:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>If a host belongs to an aggregate and the aggregate defines one or more
                            metadata that matches an image's properties, that host is a candidate to boot
                            the image's instance.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If a host does not belong to any aggregate, it can boot instances from all
                            images.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>For example, the following aggregate <literal>myWinAgg</literal> has the Windows operating
                    system as metadata (named 'windows'):</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack aggregate show MyWinAgg
+-------------------+----------------------------+
| Field             | Value                      |
+-------------------+----------------------------+
| availability_zone | zone1                      |
| created_at        | 2017-01-01T15:36:44.000000 |
| deleted           | False                      |
| deleted_at        | None                       |
| hosts             | [u'sf-devel']              |
| id                | 1                          |
| name              | test                       |
| properties        |                            |
| updated_at        | None                       |
+-------------------+----------------------------+</literal_block>
                <paragraph>In this example, because the following Win-2012 image has the <literal>windows</literal>
                    property, it boots on the <literal>sf-devel</literal> host (all other filters being equal):</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image show Win-2012
+------------------+------------------------------------------------------+
| Field            | Value                                                |
+------------------+------------------------------------------------------+
| checksum         | ee1eca47dc88f4879d8a229cc70a07c6                     |
| container_format | bare                                                 |
| created_at       | 2016-12-13T09:30:30Z                                 |
| disk_format      | qcow2                                                |
| ...</literal_block>
                <paragraph>You can configure the <literal>AggregateImagePropertiesIsolation</literal> filter by using the
                    following options in the <literal>nova.conf</literal> file:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve"># Considers only keys matching the given namespace (string).
# Multiple values can be given, as a comma-separated list.
aggregate_image_properties_isolation_namespace = &lt;None&gt;

# Separator used between the namespace and keys (string).
aggregate_image_properties_isolation_separator = .</literal_block>
                <target refid="aggregateinstanceextraspecsfilter"></target>
            </section>
            <section dupnames="aggregateinstanceextraspecsfilter" ids="aggregateinstanceextraspecsfilter id1" names="aggregateinstanceextraspecsfilter">
                <title>AggregateInstanceExtraSpecsFilter</title>
                <paragraph>Matches properties defined in extra specs for an instance type against
                    admin-defined properties on a host aggregate.  Works with specifications that
                    are scoped with <literal>aggregate_instance_extra_specs</literal>.  Multiple values can be
                    given, as a comma-separated list.  For backward compatibility, also works with
                    non-scoped specifications; this action is highly discouraged because it
                    conflicts with <reference internal="True" refid="computecapabilitiesfilter"><inline classes="std std-ref">ComputeCapabilitiesFilter</inline></reference> filter when you enable both
                    filters.  For information about how to use this filter, see the
                    <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference> section.</paragraph>
            </section>
            <section ids="aggregateioopsfilter" names="aggregateioopsfilter">
                <title>AggregateIoOpsFilter</title>
                <paragraph>Filters host by disk allocation with a per-aggregate <literal>max_io_ops_per_host</literal>
                    value. If the per-aggregate value is not found, the value falls back to the
                    global setting.  If the host is in more than one aggregate and more than one
                    value is found, the minimum value will be used.  For information about how to
                    use this filter, see <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>. See also <reference internal="True" refid="ioopsfilter"><inline classes="std std-ref">IoOpsFilter</inline></reference>.</paragraph>
            </section>
            <section ids="aggregatemultitenancyisolation" names="aggregatemultitenancyisolation">
                <title>AggregateMultiTenancyIsolation</title>
                <paragraph>Ensures that the tenant (or list of tenants) creates all instances only on
                    specific <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>. If a host is in an aggregate that has the
                    <literal>filter_tenant_id</literal> metadata key, the host creates instances from only that
                    tenant or list of tenants. A host can be in different aggregates. If a host
                    does not belong to an aggregate with the metadata key, the host can create
                    instances from all tenants. This setting does not isolate the aggregate from
                    other tenants. Any other tenant can continue to build instances on the
                    specified aggregate.</paragraph>
            </section>
            <section ids="aggregatenuminstancesfilter" names="aggregatenuminstancesfilter">
                <title>AggregateNumInstancesFilter</title>
                <paragraph>Filters host by number of instances with a per-aggregate
                    <literal>max_instances_per_host</literal> value. If the per-aggregate value is not found, the
                    value falls back to the global setting.  If the host is in more than one
                    aggregate and thus more than one value is found, the minimum value will be
                    used.  For information about how to use this filter, see
                    <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>.  See also <reference internal="True" refid="numinstancesfilter"><inline classes="std std-ref">NumInstancesFilter</inline></reference>.</paragraph>
            </section>
            <section ids="aggregateramfilter" names="aggregateramfilter">
                <title>AggregateRamFilter</title>
                <paragraph>Filters host by RAM allocation of instances with a per-aggregate
                    <literal>ram_allocation_ratio</literal> value. If the per-aggregate value is not found, the
                    value falls back to the global setting.  If the host is in more than one
                    aggregate and thus more than one value is found, the minimum value will be
                    used.  For information about how to use this filter, see
                    <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>.  See also <reference internal="True" refid="ramfilter"><inline classes="std std-ref">RamFilter</inline></reference>.</paragraph>
            </section>
            <section ids="aggregatetypeaffinityfilter" names="aggregatetypeaffinityfilter">
                <title>AggregateTypeAffinityFilter</title>
                <paragraph>This filter passes hosts if no <literal>instance_type</literal> key is set or the
                    <literal>instance_type</literal> aggregate metadata value contains the name of the
                    <literal>instance_type</literal> requested.  The value of the <literal>instance_type</literal> metadata entry
                    is a string that may contain either a single <literal>instance_type</literal> name or a
                    comma-separated list of <literal>instance_type</literal> names, such as <literal>m1.nano</literal> or
                    <literal>m1.nano,m1.small</literal>.  For information about how to use this filter, see
                    <reference internal="True" refid="host-aggregates"><inline classes="std std-ref">Host aggregates and availability zones</inline></reference>.  See also <reference internal="True" refid="typeaffinityfilter"><inline classes="std std-ref">TypeAffinityFilter</inline></reference>.</paragraph>
            </section>
            <section ids="allhostsfilter" names="allhostsfilter">
                <title>AllHostsFilter</title>
                <paragraph>This is a no-op filter. It does not eliminate any of the available hosts.</paragraph>
            </section>
            <section ids="availabilityzonefilter" names="availabilityzonefilter">
                <title>AvailabilityZoneFilter</title>
                <paragraph>Filters hosts by availability zone. You must enable this filter for the
                    scheduler to respect availability zones in requests.</paragraph>
                <target refid="computecapabilitiesfilter"></target>
            </section>
            <section dupnames="computecapabilitiesfilter" ids="computecapabilitiesfilter id2" names="computecapabilitiesfilter">
                <title>ComputeCapabilitiesFilter</title>
                <paragraph>Matches properties defined in extra specs for an instance type against compute
                    capabilities. If an extra specs key contains a colon (<literal>:</literal>), anything before
                    the colon is treated as a namespace and anything after the colon is treated as
                    the key to be matched.  If a namespace is present and is not <literal>capabilities</literal>,
                    the filter ignores the namespace. For backward compatibility, also treats the
                    extra specs key as the key to be matched if no namespace is present; this
                    action is highly discouraged because it conflicts with
                    <reference internal="True" refid="aggregateinstanceextraspecsfilter"><inline classes="std std-ref">AggregateInstanceExtraSpecsFilter</inline></reference> filter when you enable both filters.</paragraph>
                <target refid="computefilter"></target>
            </section>
            <section dupnames="computefilter" ids="computefilter id3" names="computefilter">
                <title>ComputeFilter</title>
                <paragraph>Passes all hosts that are operational and enabled.</paragraph>
                <paragraph>In general, you should always enable this filter.</paragraph>
                <target refid="corefilter"></target>
            </section>
            <section dupnames="corefilter" ids="corefilter id4" names="corefilter">
                <title>CoreFilter</title>
                <paragraph>Only schedules instances on hosts if sufficient CPU cores are available.  If
                    this filter is not set, the scheduler might over-provision a host based on
                    cores. For example, the virtual cores running on an instance may exceed the
                    physical cores.</paragraph>
                <paragraph>You can configure this filter to enable a fixed amount of vCPU overcommitment
                    by using the <literal>cpu_allocation_ratio</literal> configuration option in <literal>nova.conf</literal>.
                    The default setting is:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">cpu_allocation_ratio = 16.0</literal_block>
                <paragraph>With this setting, if 8 vCPUs are on a node, the scheduler allows instances up
                    to 128 vCPU to be run on that node.</paragraph>
                <paragraph>To disallow vCPU overcommitment set:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">cpu_allocation_ratio = 1.0</literal_block>
                <note>
                    <paragraph>The Compute API always returns the actual number of CPU cores available on a
                        compute node regardless of the value of the <literal>cpu_allocation_ratio</literal>
                        configuration key. As a result changes to the <literal>cpu_allocation_ratio</literal> are
                        not reflected via the command line clients or the dashboard.  Changes to
                        this configuration key are only taken into account internally in the
                        scheduler.</paragraph>
                </note>
            </section>
            <section ids="differenthostfilter" names="differenthostfilter">
                <title>DifferentHostFilter</title>
                <paragraph>Schedules the instance on a different host from a set of instances.  To take
                    advantage of this filter, the requester must pass a scheduler hint, using
                    <literal>different_host</literal> as the key and a list of instance UUIDs as the value. This
                    filter is the opposite of the <literal>SameHostFilter</literal>.  Using the
                    <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag. For
                    example:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server create --image cedef40a-ed67-4d10-800e-17455edce175 \
  --flavor 1 --hint different_host=a0cf03a5-d921-4877-bb5c-86d26cf818e1 \
  --hint different_host=8c19174f-4220-44f0-824a-cd1eeef10287 server-1</literal_block>
                <paragraph>With the API, use the <literal>os:scheduler_hints</literal> key. For example:</paragraph>
                <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "server": {
        "name": "server-1",
        "imageRef": "cedef40a-ed67-4d10-800e-17455edce175",
        "flavorRef": "1"
    },
    "os:scheduler_hints": {
        "different_host": [
            "a0cf03a5-d921-4877-bb5c-86d26cf818e1",
            "8c19174f-4220-44f0-824a-cd1eeef10287"
        ]
    }
}</literal_block>
                <target refid="diskfilter"></target>
            </section>
            <section dupnames="diskfilter" ids="diskfilter id5" names="diskfilter">
                <title>DiskFilter</title>
                <paragraph>Only schedules instances on hosts if there is sufficient disk space available
                    for root and ephemeral storage.</paragraph>
                <paragraph>You can configure this filter to enable a fixed amount of disk overcommitment
                    by using the <literal>disk_allocation_ratio</literal> configuration option in the
                    <literal>nova.conf</literal> configuration file.  The default setting disables the possibility
                    of the overcommitment and allows launching a VM only if there is a sufficient
                    amount of disk space available on a host:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">disk_allocation_ratio = 1.0</literal_block>
                <paragraph>DiskFilter always considers the value of the <literal>disk_available_least</literal> property
                    and not the one of the <literal>free_disk_gb</literal> property of a hypervisor's statistics:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack hypervisor stats show
+----------------------+-------+
| Field                | Value |
+----------------------+-------+
| count                | 1     |
| current_workload     | 0     |
| disk_available_least | 14    |
| free_disk_gb         | 27    |
| free_ram_mb          | 15374 |
| local_gb             | 27    |
| local_gb_used        | 0     |
| memory_mb            | 15886 |
| memory_mb_used       | 512   |
| running_vms          | 0     |
| vcpus                | 8     |
| vcpus_used           | 0     |
+----------------------+-------+</literal_block>
                <paragraph>As it can be viewed from the command output above, the amount of the available
                    disk space can be less than the amount of the free disk space.  It happens
                    because the <literal>disk_available_least</literal> property accounts for the virtual size
                    rather than the actual size of images.  If you use an image format that is
                    sparse or copy on write so that each virtual instance does not require a 1:1
                    allocation of a virtual disk to a physical storage, it may be useful to allow
                    the overcommitment of disk space.</paragraph>
                <paragraph>To enable scheduling instances while overcommitting disk resources on the node,
                    adjust the value of the <literal>disk_allocation_ratio</literal> configuration option to
                    greater than <literal>1.0</literal>:</paragraph>
                <literal_block highlight_args="{}" language="none" linenos="False" xml:space="preserve">disk_allocation_ratio &gt; 1.0</literal_block>
                <note>
                    <paragraph>If the value is set to <literal>&gt;1</literal>, we recommend keeping track of the free disk
                        space, as the value approaching <literal>0</literal> may result in the incorrect
                        functioning of instances using it at the moment.</paragraph>
                </note>
            </section>
            <section ids="exactcorefilter" names="exactcorefilter">
                <title>ExactCoreFilter</title>
                <paragraph>Only schedules instances on hosts if host has the exact number of CPU cores.</paragraph>
            </section>
            <section ids="exactdiskfilter" names="exactdiskfilter">
                <title>ExactDiskFilter</title>
                <paragraph>Only schedules instances on hosts if host has the exact amount of disk
                    available.</paragraph>
            </section>
            <section ids="exactramfilter" names="exactramfilter">
                <title>ExactRamFilter</title>
                <paragraph>Only schedules instances on hosts if host has the exact number of RAM
                    available.</paragraph>
                <target refid="imagepropertiesfilter"></target>
            </section>
            <section dupnames="imagepropertiesfilter" ids="imagepropertiesfilter id6" names="imagepropertiesfilter">
                <title>ImagePropertiesFilter</title>
                <paragraph>Filters hosts based on properties defined on the instance's image.  It passes
                    hosts that can support the specified image properties contained in the
                    instance. Properties include the architecture, hypervisor type, hypervisor
                    version (for Xen hypervisor type only), and virtual machine mode.</paragraph>
                <paragraph>For example, an instance might require a host that runs an ARM-based processor,
                    and QEMU as the hypervisor.  You can decorate an image with these properties by
                    using:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image set --architecture arm --property hypervisor_type=qemu \
  img-uuid</literal_block>
                <paragraph>The image properties that the filter checks for are:</paragraph>
                <definition_list>
                    <definition_list_item>
                        <term><literal>architecture</literal></term>
                        <definition>
                            <paragraph>describes the machine architecture required by the image.  Examples are
                                <literal>i686</literal>, <literal>x86_64</literal>, <literal>arm</literal>, and <literal>ppc64</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term><literal>hypervisor_type</literal></term>
                        <definition>
                            <paragraph>describes the hypervisor required by the image.  Examples are <literal>xen</literal>,
                                <literal>qemu</literal>, and <literal>xenapi</literal>.</paragraph>
                            <note>
                                <paragraph><literal>qemu</literal> is used for both QEMU and KVM hypervisor types.</paragraph>
                            </note>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term><literal>hypervisor_version_requires</literal></term>
                        <definition>
                            <paragraph>describes the hypervisor version required by the image.  The property is
                                supported for Xen hypervisor type only.  It can be used to enable support for
                                multiple hypervisor versions, and to prevent instances with newer Xen tools
                                from being provisioned on an older version of a hypervisor. If available, the
                                property value is compared to the hypervisor version of the compute host.</paragraph>
                            <paragraph>To filter the hosts by the hypervisor version, add the
                                <literal>hypervisor_version_requires</literal> property on the image as metadata and pass an
                                operator and a required hypervisor version as its value:</paragraph>
                            <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack image set --property hypervisor_type=xen --property \
  hypervisor_version_requires="&gt;=4.3" img-uuid</literal_block>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term><literal>vm_mode</literal></term>
                        <definition>
                            <paragraph>describes the hypervisor application binary interface (ABI) required by the
                                image. Examples are <literal>xen</literal> for Xen 3.0 paravirtual ABI, <literal>hvm</literal> for native
                                ABI, <literal>uml</literal> for User Mode Linux paravirtual ABI, <literal>exe</literal> for container virt
                                executable ABI.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </section>
            <section ids="isolatedhostsfilter" names="isolatedhostsfilter">
                <title>IsolatedHostsFilter</title>
                <paragraph>Allows the admin to define a special (isolated) set of images and a special
                    (isolated) set of hosts, such that the isolated images can only run on the
                    isolated hosts, and the isolated hosts can only run isolated images.  The flag
                    <literal>restrict_isolated_hosts_to_isolated_images</literal> can be used to force isolated
                    hosts to only run isolated images.</paragraph>
                <paragraph>The admin must specify the isolated set of images and hosts in the
                    <literal>nova.conf</literal> file using the <literal>isolated_hosts</literal> and <literal>isolated_images</literal>
                    configuration options. For example:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[filter_scheduler]
isolated_hosts = server1, server2
isolated_images = 342b492c-128f-4a42-8d3a-c5088cf27d13, ebd267a6-ca86-4d6c-9a0e-bd132d6b7d09</literal_block>
                <target refid="ioopsfilter"></target>
            </section>
            <section dupnames="ioopsfilter" ids="ioopsfilter id7" names="ioopsfilter">
                <title>IoOpsFilter</title>
                <paragraph>The IoOpsFilter filters hosts by concurrent I/O operations on it.  Hosts with
                    too many concurrent I/O operations will be filtered out.  The
                    <literal>max_io_ops_per_host</literal> option specifies the maximum number of I/O intensive
                    instances allowed to run on a host.  A host will be ignored by the scheduler if
                    more than <literal>max_io_ops_per_host</literal> instances in build, resize, snapshot,
                    migrate, rescue or unshelve task states are running on it.</paragraph>
            </section>
            <section ids="jsonfilter" names="jsonfilter">
                <title>JsonFilter</title>
                <paragraph>The JsonFilter allows a user to construct a custom filter by passing a
                    scheduler hint in JSON format. The following operators are supported:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>=</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>&lt;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>&gt;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>in</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>&lt;=</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>&gt;=</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>not</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>or</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>and</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The filter supports the following variables:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><literal>$free_ram_mb</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>$free_disk_mb</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>$total_usable_ram_mb</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>$vcpus_total</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>$vcpus_used</literal></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Using the <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server create --image 827d564a-e636-4fc4-a376-d36f7ebe1747 \
  --flavor 1 --hint query='["&gt;=","$free_ram_mb",1024]' server1</literal_block>
                <paragraph>With the API, use the <literal>os:scheduler_hints</literal> key:</paragraph>
                <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "server": {
        "name": "server-1",
        "imageRef": "cedef40a-ed67-4d10-800e-17455edce175",
        "flavorRef": "1"
    },
    "os:scheduler_hints": {
        "query": "[&gt;=,$free_ram_mb,1024]"
    }
}</literal_block>
            </section>
            <section ids="metricsfilter" names="metricsfilter">
                <title>MetricsFilter</title>
                <paragraph>Filters hosts based on meters <literal>weight_setting</literal>.  Only hosts with the
                    available meters are passed so that the metrics weigher will not fail due to
                    these hosts.</paragraph>
            </section>
            <section ids="numatopologyfilter" names="numatopologyfilter">
                <title>NUMATopologyFilter</title>
                <paragraph>Filters hosts based on the NUMA topology that was specified for the instance
                    through the use of flavor <literal>extra_specs</literal> in combination with the image
                    properties, as described in detail in the <reference name="related nova-spec document" refuri="http://specs.openstack.org/openstack/nova-specs/specs/juno/implemented/virt-driver-numa-placement.html">related nova-spec document</reference><target ids="related-nova-spec-document" names="related\ nova-spec\ document" refuri="http://specs.openstack.org/openstack/nova-specs/specs/juno/implemented/virt-driver-numa-placement.html"></target>.  Filter
                    will try to match the exact NUMA cells of the instance to those of the host. It
                    will consider the standard over-subscription limits each cell, and provide
                    limits to the compute host accordingly.</paragraph>
                <note>
                    <paragraph>If instance has no topology defined, it will be considered for any host.  If
                        instance has a topology defined, it will be considered only for NUMA capable
                        hosts.</paragraph>
                </note>
                <target refid="numinstancesfilter"></target>
            </section>
            <section dupnames="numinstancesfilter" ids="numinstancesfilter id8" names="numinstancesfilter">
                <title>NumInstancesFilter</title>
                <paragraph>Hosts that have more instances running than specified by the
                    <literal>max_instances_per_host</literal> option are filtered out when this filter is in
                    place.</paragraph>
            </section>
            <section ids="pcipassthroughfilter" names="pcipassthroughfilter">
                <title>PciPassthroughFilter</title>
                <paragraph>The filter schedules instances on a host if the host has devices that meet the
                    device requests in the <literal>extra_specs</literal> attribute for the flavor.</paragraph>
                <target refid="ramfilter"></target>
            </section>
            <section dupnames="ramfilter" ids="ramfilter id9" names="ramfilter">
                <title>RamFilter</title>
                <paragraph>Only schedules instances on hosts that have sufficient RAM available.  If this
                    filter is not set, the scheduler may over provision a host based on RAM (for
                    example, the RAM allocated by virtual machine instances may exceed the physical
                    RAM).</paragraph>
                <paragraph>You can configure this filter to enable a fixed amount of RAM overcommitment by
                    using the <literal>ram_allocation_ratio</literal> configuration option in <literal>nova.conf</literal>. The
                    default setting is:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">ram_allocation_ratio = 1.5</literal_block>
                <paragraph>This setting enables 1.5 GB instances to run on any compute node with 1 GB of
                    free RAM.</paragraph>
            </section>
            <section ids="retryfilter" names="retryfilter">
                <title>RetryFilter</title>
                <paragraph>Filters out hosts that have already been attempted for scheduling purposes.  If
                    the scheduler selects a host to respond to a service request, and the host
                    fails to respond to the request, this filter prevents the scheduler from
                    retrying that host for the service request.</paragraph>
                <paragraph>This filter is only useful if the <literal>scheduler_max_attempts</literal> configuration
                    option is set to a value greater than zero.</paragraph>
            </section>
            <section ids="samehostfilter" names="samehostfilter">
                <title>SameHostFilter</title>
                <paragraph>Schedules the instance on the same host as another instance in a set of
                    instances. To take advantage of this filter, the requester must pass a
                    scheduler hint, using <literal>same_host</literal> as the key and a list of instance UUIDs as
                    the value.  This filter is the opposite of the <literal>DifferentHostFilter</literal>.  Using
                    the <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server create --image cedef40a-ed67-4d10-800e-17455edce175 \
  --flavor 1 --hint same_host=a0cf03a5-d921-4877-bb5c-86d26cf818e1 \
  --hint same_host=8c19174f-4220-44f0-824a-cd1eeef10287 server-1</literal_block>
                <paragraph>With the API, use the <literal>os:scheduler_hints</literal> key:</paragraph>
                <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "server": {
        "name": "server-1",
        "imageRef": "cedef40a-ed67-4d10-800e-17455edce175",
        "flavorRef": "1"
    },
    "os:scheduler_hints": {
        "same_host": [
            "a0cf03a5-d921-4877-bb5c-86d26cf818e1",
            "8c19174f-4220-44f0-824a-cd1eeef10287"
        ]
    }
}</literal_block>
                <target refid="servergroupaffinityfilter"></target>
            </section>
            <section dupnames="servergroupaffinityfilter" ids="servergroupaffinityfilter id10" names="servergroupaffinityfilter">
                <title>ServerGroupAffinityFilter</title>
                <paragraph>The ServerGroupAffinityFilter ensures that an instance is scheduled on to a
                    host from a set of group hosts. To take advantage of this filter, the requester
                    must create a server group with an <literal>affinity</literal> policy, and pass a scheduler
                    hint, using <literal>group</literal> as the key and the server group UUID as the value.  Using
                    the <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag. For
                    example:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server group create --policy affinity group-1
$ openstack server create --image IMAGE_ID --flavor 1 \
  --hint group=SERVER_GROUP_UUID server-1</literal_block>
                <target refid="servergroupantiaffinityfilter"></target>
            </section>
            <section dupnames="servergroupantiaffinityfilter" ids="servergroupantiaffinityfilter id11" names="servergroupantiaffinityfilter">
                <title>ServerGroupAntiAffinityFilter</title>
                <paragraph>The ServerGroupAntiAffinityFilter ensures that each instance in a group is on a
                    different host. To take advantage of this filter, the requester must create a
                    server group with an <literal>anti-affinity</literal> policy, and pass a scheduler hint, using
                    <literal>group</literal> as the key and the server group UUID as the value.  Using the
                    <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag. For
                    example:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server group create --policy anti-affinity group-1
$ openstack server create --image IMAGE_ID --flavor 1 \
  --hint group=SERVER_GROUP_UUID server-1</literal_block>
            </section>
            <section ids="simplecidraffinityfilter" names="simplecidraffinityfilter">
                <title>SimpleCIDRAffinityFilter</title>
                <paragraph>Schedules the instance based on host IP subnet range.  To take advantage of
                    this filter, the requester must specify a range of valid IP address in CIDR
                    format, by passing two scheduler hints:</paragraph>
                <definition_list>
                    <definition_list_item>
                        <term><literal>build_near_host_ip</literal></term>
                        <definition>
                            <paragraph>The first IP address in the subnet (for example, <literal>192.168.1.1</literal>)</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term><literal>cidr</literal></term>
                        <definition>
                            <paragraph>The CIDR that corresponds to the subnet (for example, <literal>/24</literal>)</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
                <paragraph>Using the <literal_strong classes="command">openstack server create</literal_strong> command, use the <literal>--hint</literal> flag.
                    For example, to specify the IP subnet <literal>192.168.1.1/24</literal>:</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack server create --image cedef40a-ed67-4d10-800e-17455edce175 \
  --flavor 1 --hint build_near_host_ip=192.168.1.1 --hint cidr=/24 server-1</literal_block>
                <paragraph>With the API, use the <literal>os:scheduler_hints</literal> key:</paragraph>
                <literal_block highlight_args="{}" language="json" linenos="False" xml:space="preserve">{
    "server": {
        "name": "server-1",
        "imageRef": "cedef40a-ed67-4d10-800e-17455edce175",
        "flavorRef": "1"
    },
    "os:scheduler_hints": {
        "build_near_host_ip": "192.168.1.1",
        "cidr": "24"
    }
}</literal_block>
            </section>
            <section ids="trustedfilter" names="trustedfilter">
                <title>TrustedFilter</title>
                <paragraph>Filters hosts based on their trust. Only passes hosts that meet the trust
                    requirements specified in the instance properties.</paragraph>
                <target refid="typeaffinityfilter"></target>
            </section>
            <section dupnames="typeaffinityfilter" ids="typeaffinityfilter id12" names="typeaffinityfilter">
                <title>TypeAffinityFilter</title>
                <paragraph>Dynamically limits hosts to one instance type. An instance can only be launched
                    on a host, if no instance with different instances types are running on it, or
                    if the host has no running instances at all.</paragraph>
            </section>
        </section>
        <section ids="cell-filters" names="cell\ filters">
            <title>Cell filters</title>
            <paragraph>The following sections describe the available cell filters.</paragraph>
            <section ids="differentcellfilter" names="differentcellfilter">
                <title>DifferentCellFilter</title>
                <paragraph>Schedules the instance on a different cell from a set of instances.  To take
                    advantage of this filter, the requester must pass a scheduler hint, using
                    <literal>different_cell</literal> as the key and a list of instance UUIDs as the value.</paragraph>
            </section>
            <section dupnames="imagepropertiesfilter" ids="id13">
                <title>ImagePropertiesFilter</title>
                <paragraph>Filters cells based on properties defined on the instances image.  This
                    filter works specifying the hypervisor required in the image metadata and the
                    supported hypervisor version in cell capabilities.</paragraph>
            </section>
            <section ids="targetcellfilter" names="targetcellfilter">
                <title>TargetCellFilter</title>
                <paragraph>Filters target cells. This filter works by specifying a scheduler hint of
                    <literal>target_cell</literal>. The value should be the full cell path.</paragraph>
                <target refid="weights"></target>
            </section>
        </section>
        <section dupnames="weights" ids="weights id14" names="weights">
            <title>Weights</title>
            <paragraph>When resourcing instances, the filter scheduler filters and weights each host
                in the list of acceptable hosts. Each time the scheduler selects a host, it
                virtually consumes resources on it, and subsequent selections are adjusted
                accordingly. This process is useful when the customer asks for the same large
                amount of instances, because weight is computed for each requested instance.</paragraph>
            <paragraph>All weights are normalized before being summed up; the host with the largest
                weight is given the highest priority.</paragraph>
            <paragraph><strong>Weighting hosts</strong></paragraph>
            <figure>
                <image candidates="{'*': u'figures/nova-weighting-hosts.png'}" uri="figures/nova-weighting-hosts.png"></image>
            </figure>
            <paragraph>If cells are used, cells are weighted by the scheduler in the same manner as
                hosts.</paragraph>
            <paragraph>Hosts and cells are weighted based on the following options in the
                <literal>/etc/nova/nova.conf</literal> file:</paragraph>
            <table classes="colwidths-given" ids="id15">
                <title>Host weighting options</title>
                <tgroup cols="3">
                    <colspec colwidth="10"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="60"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Section</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Option</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>ram_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>By default, the scheduler spreads instances across all hosts evenly.
                                    Set the <literal>ram_weight_multiplier</literal> option to a negative number if you
                                    prefer stacking instead of spreading. Use a floating-point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>scheduler_host_subset_size</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>New instances are scheduled on a host that is chosen randomly from a
                                    subset of the N best hosts. This property defines the subset size from
                                    which a host is chosen. A value of 1 chooses the first host returned by
                                    the weighting functions. This value must be at least 1.  A value less
                                    than 1 is ignored, and 1 is used instead.  Use an integer value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>scheduler_weight_classes</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Defaults to <literal>nova.scheduler.weights.all_weighers</literal>.  Hosts are then
                                    weighted and sorted with the largest weight winning.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>io_ops_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier used for weighing host I/O operations. A negative value means
                                    a preference to choose light workload compute hosts.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>soft_affinity_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier used for weighing hosts for group soft-affinity.  Only a
                                    positive value is meaningful. Negative means that the behavior will
                                    change to the opposite, which is soft-anti-affinity.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[DEFAULT]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>soft_anti_affinity_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier used for weighing hosts for group soft-anti-affinity.  Only a
                                    positive value is meaningful. Negative means that the behavior will
                                    change to the opposite, which is soft-affinity.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[metrics]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier for weighting meters. Use a floating-point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[metrics]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>weight_setting</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Determines how meters are weighted. Use a comma-separated list of
                                    metricName=ratio. For example: <literal>name1=1.0, name2=-1.0</literal> results in:
                                    <literal>name1.value * 1.0 + name2.value * -1.0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[metrics]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>required</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Specifies how to treat unavailable meters:</paragraph>
                                <bullet_list bullet="*">
                                    <list_item>
                                        <paragraph>True - Raises an exception. To avoid the raised exception, you should
                                            use the scheduler filter <literal>MetricFilter</literal> to filter out hosts with
                                            unavailable meters.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>False - Treated as a negative factor in the weighting process (uses
                                            the <literal>weight_of_unavailable</literal> option).</paragraph>
                                    </list_item>
                                </bullet_list>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[metrics]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>weight_of_unavailable</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>If <literal>required</literal> is set to False, and any one of the meters set by
                                    <literal>weight_setting</literal> is unavailable, the <literal>weight_of_unavailable</literal> value
                                    is returned to the scheduler.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>For example:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[DEFAULT]
scheduler_host_subset_size = 1
scheduler_weight_classes = nova.scheduler.weights.all_weighers
ram_weight_multiplier = 1.0
io_ops_weight_multiplier = 2.0
soft_affinity_weight_multiplier = 1.0
soft_anti_affinity_weight_multiplier = 1.0
[metrics]
weight_multiplier = 1.0
weight_setting = name1=1.0, name2=-1.0
required = false
weight_of_unavailable = -10000.0</literal_block>
            <table classes="colwidths-given" ids="id16">
                <title>Cell weighting options</title>
                <tgroup cols="3">
                    <colspec colwidth="10"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="60"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Section</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Option</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>[cells]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>mute_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier to weight mute children (hosts which have not sent
                                    capacity or capacity updates for some time).
                                    Use a negative, floating-point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[cells]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>offset_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplier to weight cells, so you can specify a preferred cell.
                                    Use a floating point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[cells]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>ram_weight_multiplier</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>By default, the scheduler spreads instances across all cells evenly.
                                    Set the <literal>ram_weight_multiplier</literal> option to a negative number if you
                                    prefer stacking instead of spreading. Use a floating-point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>[cells]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>scheduler_weight_classes</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Defaults to <literal>nova.cells.weights.all_weighers</literal>, which maps to all
                                    cell weighers included with Compute. Cells are then weighted and
                                    sorted with the largest weight winning.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>For example:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[cells]
scheduler_weight_classes = nova.cells.weights.all_weighers
mute_weight_multiplier = -10.0
ram_weight_multiplier = 1.0
offset_weight_multiplier = 1.0</literal_block>
        </section>
        <section ids="chance-scheduler" names="chance\ scheduler">
            <title>Chance scheduler</title>
            <paragraph>As an administrator, you work with the filter scheduler.  However, the Compute
                service also uses the Chance Scheduler,
                <literal>nova.scheduler.chance.ChanceScheduler</literal>, which randomly selects from lists of
                filtered hosts.</paragraph>
        </section>
        <section ids="utilization-aware-scheduling" names="utilization\ aware\ scheduling">
            <title>Utilization aware scheduling</title>
            <paragraph>It is possible to schedule VMs using advanced scheduling decisions.  These
                decisions are made based on enhanced usage statistics encompassing data like
                memory cache utilization, memory bandwidth utilization, or network bandwidth
                utilization. This is disabled by default.  The administrator can configure how
                the metrics are weighted in the configuration file by using the
                <literal>weight_setting</literal> configuration option in the <literal>nova.conf</literal> configuration
                file.  For example to configure metric1 with ratio1 and metric2 with ratio2:</paragraph>
            <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">weight_setting = "metric1=ratio1, metric2=ratio2"</literal_block>
            <target refid="host-aggregates"></target>
        </section>
        <section ids="host-aggregates-and-availability-zones host-aggregates" names="host\ aggregates\ and\ availability\ zones host-aggregates">
            <title>Host aggregates and availability zones</title>
            <paragraph>Host aggregates are a mechanism for partitioning hosts in an OpenStack cloud,
                or a region of an OpenStack cloud, based on arbitrary characteristics.
                Examples where an administrator may want to do this include where a group of
                hosts have additional hardware or performance characteristics.</paragraph>
            <paragraph>Host aggregates are not explicitly exposed to users.  Instead administrators
                map flavors to host aggregates.  Administrators do this by setting metadata on
                a host aggregate, and matching flavor extra specifications.  The scheduler then
                endeavors to match user requests for instance of the given flavor to a host
                aggregate with the same key-value pair in its metadata.  Compute nodes can be
                in more than one host aggregate.</paragraph>
            <paragraph>Administrators are able to optionally expose a host aggregate as an
                availability zone. Availability zones are different from host aggregates in
                that they are explicitly exposed to the user, and hosts can only be in a single
                availability zone. Administrators can configure a default availability zone
                where instances will be scheduled when the user fails to specify one.</paragraph>
            <section ids="command-line-interface" names="command-line\ interface">
                <title>Command-line interface</title>
                <paragraph>The <literal_strong classes="command">nova</literal_strong> command-line client supports the following
                    aggregate-related commands.</paragraph>
                <definition_list>
                    <definition_list_item>
                        <term>nova aggregate-list</term>
                        <definition>
                            <paragraph>Print a list of all aggregates.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-create &lt;name&gt; [availability-zone]</term>
                        <definition>
                            <paragraph>Create a new aggregate named <literal>&lt;name&gt;</literal>, and optionally in availability zone
                                <literal>[availability-zone]</literal> if specified. The command returns the ID of the newly
                                created aggregate. Hosts can be made available to multiple host aggregates.
                                Be careful when adding a host to an additional host aggregate when the host
                                is also in an availability zone. Pay attention when using the <literal_strong classes="command">nova
                                    aggregate-set-metadata</literal_strong> and <literal_strong classes="command">nova aggregate-update</literal_strong> commands to
                                avoid user confusion when they boot instances in different availability
                                zones.  An error occurs if you cannot add a particular host to an aggregate
                                zone for which it is not intended.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-delete &lt;aggregate&gt;</term>
                        <definition>
                            <paragraph>Delete an aggregate with its <literal>&lt;id&gt;</literal> or <literal>&lt;name&gt;</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-show &lt;aggregate&gt;</term>
                        <definition>
                            <paragraph>Show details of the aggregate with its <literal>&lt;id&gt;</literal> or <literal>&lt;name&gt;</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-add-host &lt;aggregate&gt; &lt;host&gt;</term>
                        <definition>
                            <paragraph>Add host with name <literal>&lt;host&gt;</literal> to aggregate with its <literal>&lt;id&gt;</literal> or <literal>&lt;name&gt;</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-remove-host &lt;aggregate&gt; &lt;host&gt;</term>
                        <definition>
                            <paragraph>Remove the host with name <literal>&lt;host&gt;</literal> from the aggregate with its <literal>&lt;id&gt;</literal>
                                or <literal>&lt;name&gt;</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-set-metadata &lt;aggregate&gt; &lt;key=value&gt; [&lt;key=value&gt; ...]</term>
                        <definition>
                            <paragraph>Add or update metadata (key-value pairs) associated with the aggregate with
                                its <literal>&lt;id&gt;</literal> or <literal>&lt;name&gt;</literal>.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova aggregate-update &lt;id&gt; &lt;name&gt; [&lt;availability_zone&gt;]</term>
                        <definition>
                            <paragraph>Update the name and availability zone (optional) for the aggregate.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova host-list</term>
                        <definition>
                            <paragraph>List all hosts by service.</paragraph>
                        </definition>
                    </definition_list_item>
                    <definition_list_item>
                        <term>nova host-update --maintenance [enable | disable]</term>
                        <definition>
                            <paragraph>Put/resume host into/from maintenance.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
                <note>
                    <paragraph>Only administrators can access these commands. If you try to use these
                        commands and the user name and tenant that you use to access the Compute
                        service do not have the <literal>admin</literal> role or the appropriate privileges, these
                        errors occur:</paragraph>
                    <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">ERROR: Policy doesn't allow compute_extension:aggregates to be performed. (HTTP 403) (Request-ID: req-299fbff6-6729-4cef-93b2-e7e1f96b4864)</literal_block>
                    <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">ERROR: Policy doesn't allow compute_extension:hosts to be performed. (HTTP 403) (Request-ID: req-ef2400f6-6776-4ea3-b6f1-7704085c27d1)</literal_block>
                </note>
            </section>
            <section ids="configure-scheduler-to-support-host-aggregates" names="configure\ scheduler\ to\ support\ host\ aggregates">
                <title>Configure scheduler to support host aggregates</title>
                <paragraph>One common use case for host aggregates is when you want to support scheduling
                    instances to a subset of compute hosts because they have a specific capability.
                    For example, you may want to allow users to request compute hosts that have SSD
                    drives if they need access to faster disk I/O, or access to compute hosts that
                    have GPU cards to take advantage of GPU-accelerated code.</paragraph>
                <paragraph>To configure the scheduler to support host aggregates, the
                    <literal>scheduler_default_filters</literal> configuration option must contain the
                    <literal>AggregateInstanceExtraSpecsFilter</literal> in addition to the other filters used by
                    the scheduler. Add the following line to <literal>/etc/nova/nova.conf</literal> on the host
                    that runs the <literal>nova-scheduler</literal> service to enable host aggregates filtering,
                    as well as the other filters that are typically enabled:</paragraph>
                <literal_block highlight_args="{}" language="ini" linenos="False" xml:space="preserve">scheduler_default_filters=AggregateInstanceExtraSpecsFilter,RetryFilter,AvailabilityZoneFilter,RamFilter,ComputeFilter,ComputeCapabilitiesFilter,ImagePropertiesFilter,ServerGroupAntiAffinityFilter,ServerGroupAffinityFilter</literal_block>
            </section>
            <section ids="example-specify-compute-hosts-with-ssds" names="example:\ specify\ compute\ hosts\ with\ ssds">
                <title>Example: Specify compute hosts with SSDs</title>
                <paragraph>This example configures the Compute service to enable users to request nodes
                    that have solid-state drives (SSDs). You create a <literal>fast-io</literal> host aggregate in
                    the <literal>nova</literal> availability zone and you add the <literal>ssd=true</literal> key-value pair to
                    the aggregate. Then, you add the <literal>node1</literal>, and <literal>node2</literal> compute nodes to it.</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack aggregate create --zone nova fast-io
+-------------------+----------------------------+
| Field             | Value                      |
+-------------------+----------------------------+
| availability_zone | nova                       |
| created_at        | 2016-12-22T07:31:13.013466 |
| deleted           | False                      |
| deleted_at        | None                       |
| id                | 1                          |
| name              | fast-io                    |
| updated_at        | None                       |
+-------------------+----------------------------+

$ openstack aggregate set --property ssd=true 1
+-------------------+----------------------------+
| Field             | Value                      |
+-------------------+----------------------------+
| availability_zone | nova                       |
| created_at        | 2016-12-22T07:31:13.000000 |
| deleted           | False                      |
| deleted_at        | None                       |
| hosts             | []                         |
| id                | 1                          |
| name              | fast-io                    |
| properties        | ssd='true'                 |
| updated_at        | None                       |
+-------------------+----------------------------+

$ openstack aggregate add host 1 node1
+-------------------+--------------------------------------------------+
| Field             | Value                                            |
+-------------------+--------------------------------------------------+
| availability_zone | nova                                             |
| created_at        | 2016-12-22T07:31:13.000000                       |
| deleted           | False                                            |
| deleted_at        | None                                             |
| hosts             | [u'node1']                                       |
| id                | 1                                                |
| metadata          | {u'ssd': u'true', u'availability_zone': u'nova'} |
| name              | fast-io                                          |
| updated_at        | None                                             |
+-------------------+--------------------------------------------------+

$ openstack aggregate add host 1 node2
+-------------------+--------------------------------------------------+
| Field             | Value                                            |
+-------------------+--------------------------------------------------+
| availability_zone | nova                                             |
| created_at        | 2016-12-22T07:31:13.000000                       |
| deleted           | False                                            |
| deleted_at        | None                                             |
| hosts             | [u'node2']                                       |
| id                | 1                                                |
| metadata          | {u'ssd': u'true', u'availability_zone': u'nova'} |
| name              | fast-io                                          |
| updated_at        | None                                             |
+-------------------+--------------------------------------------------+</literal_block>
                <paragraph>Use the <literal_strong classes="command">openstack flavor create</literal_strong> command to create the <literal>ssd.large</literal>
                    flavor called with an ID of 6, 8 GB of RAM, 80 GB root disk, and 4 vCPUs.</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor create --id 6 --ram 8192 --disk 80 --vcpus 4 ssd.large
+----------------------------+-----------+
| Field                      | Value     |
+----------------------------+-----------+
| OS-FLV-DISABLED:disabled   | False     |
| OS-FLV-EXT-DATA:ephemeral  | 0         |
| disk                       | 80        |
| id                         | 6         |
| name                       | ssd.large |
| os-flavor-access:is_public | True      |
| ram                        | 8192      |
| rxtx_factor                | 1.0       |
| swap                       |           |
| vcpus                      | 4         |
+----------------------------+-----------+</literal_block>
                <paragraph>Once the flavor is created, specify one or more key-value pairs that match the
                    key-value pairs on the host aggregates with scope
                    <literal>aggregate_instance_extra_specs</literal>. In this case, that is the
                    <literal>aggregate_instance_extra_specs:ssd=true</literal> key-value pair.  Setting a
                    key-value pair on a flavor is done using the <literal_strong classes="command">openstack flavor set</literal_strong>
                    command.</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor set --property aggregate_instance_extra_specs:ssd=true ssd.large</literal_block>
                <paragraph>Once it is set, you should see the <literal>extra_specs</literal> property of the
                    <literal>ssd.large</literal> flavor populated with a key of <literal>ssd</literal> and a corresponding value
                    of <literal>true</literal>.</paragraph>
                <literal_block highlight_args="{}" language="console" linenos="False" xml:space="preserve">$ openstack flavor show ssd.large
+----------------------------+-------------------------------------------+
| Field                      | Value                                     |
+----------------------------+-------------------------------------------+
| OS-FLV-DISABLED:disabled   | False                                     |
| OS-FLV-EXT-DATA:ephemeral  | 0                                         |
| disk                       | 80                                        |
| id                         | 6                                         |
| name                       | ssd.large                                 |
| os-flavor-access:is_public | True                                      |
| properties                 | aggregate_instance_extra_specs:ssd='true' |
| ram                        | 8192                                      |
| rxtx_factor                | 1.0                                       |
| swap                       |                                           |
| vcpus                      | 4                                         |
+----------------------------+-------------------------------------------+</literal_block>
                <paragraph>Now, when a user requests an instance with the <literal>ssd.large</literal> flavor,
                    the scheduler only considers hosts with the <literal>ssd=true</literal> key-value pair.
                    In this example, these are <literal>node1</literal> and <literal>node2</literal>.</paragraph>
            </section>
            <section ids="xenserver-hypervisor-pools-to-support-live-migration" names="xenserver\ hypervisor\ pools\ to\ support\ live\ migration">
                <title>XenServer hypervisor pools to support live migration</title>
                <paragraph>When using the XenAPI-based hypervisor, the Compute service uses host
                    aggregates to manage XenServer Resource pools, which are used in supporting
                    live migration.</paragraph>
            </section>
        </section>
    </section>
</document>
